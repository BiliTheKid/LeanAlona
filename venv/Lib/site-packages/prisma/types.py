# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# UserAnswer types

class UserAnswerOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the UserAnswer create method"""
    id: _int
    settlementCode: _int
    hotelOption1: Optional[_str]
    hotelOption2: Optional[_str]
    hotelOption3: Optional[_str]
    selectedHotel: Optional[_str]
    settlement: 'SettlementCreateNestedWithoutRelationsInput'


class UserAnswerCreateInput(UserAnswerOptionalCreateInput):
    """Required arguments to the UserAnswer create method"""
    idNumber: _str
    fullName: _str
    accessibility: _bool
    pets: _bool
    numberOfPeople: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserAnswerOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the UserAnswer create method, without relations"""
    id: _int
    settlementCode: _int
    hotelOption1: Optional[_str]
    hotelOption2: Optional[_str]
    hotelOption3: Optional[_str]
    selectedHotel: Optional[_str]


class UserAnswerCreateWithoutRelationsInput(UserAnswerOptionalCreateWithoutRelationsInput):
    """Required arguments to the UserAnswer create method, without relations"""
    idNumber: _str
    fullName: _str
    accessibility: _bool
    pets: _bool
    numberOfPeople: _int


class UserAnswerCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserAnswerCreateWithoutRelationsInput'
    connect: 'UserAnswerWhereUniqueInput'


class UserAnswerCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserAnswerCreateWithoutRelationsInput', List['UserAnswerCreateWithoutRelationsInput']]
    connect: Union['UserAnswerWhereUniqueInput', List['UserAnswerWhereUniqueInput']]


_UserAnswerWhereUnique_id_Input = TypedDict(
    '_UserAnswerWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_UserAnswerWhereUnique_idNumber_Input = TypedDict(
    '_UserAnswerWhereUnique_idNumber_Input',
    {
        'idNumber': '_str',
    },
    total=True
)

UserAnswerWhereUniqueInput = Union[
    '_UserAnswerWhereUnique_id_Input',
    '_UserAnswerWhereUnique_idNumber_Input',
]


class UserAnswerUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    idNumber: _str
    fullName: _str
    accessibility: _bool
    pets: _bool
    numberOfPeople: Union[AtomicIntInput, _int]
    hotelOption1: Optional[_str]
    hotelOption2: Optional[_str]
    hotelOption3: Optional[_str]
    selectedHotel: Optional[_str]
    settlement: 'SettlementUpdateOneWithoutRelationsInput'


class UserAnswerUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    idNumber: _str
    fullName: _str
    accessibility: _bool
    pets: _bool
    numberOfPeople: Union[AtomicIntInput, _int]
    hotelOption1: Optional[_str]
    hotelOption2: Optional[_str]
    hotelOption3: Optional[_str]
    selectedHotel: Optional[_str]


class UserAnswerUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserAnswerCreateWithoutRelationsInput']
    connect: List['UserAnswerWhereUniqueInput']
    set: List['UserAnswerWhereUniqueInput']
    disconnect: List['UserAnswerWhereUniqueInput']
    delete: List['UserAnswerWhereUniqueInput']

    # TODO
    # update: List['UserAnswerUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserAnswerUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserAnswerScalarWhereInput']
    # upsert: List['UserAnswerUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['UserAnswerCreateOrConnectWithoutRelationsInput']


class UserAnswerUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserAnswerCreateWithoutRelationsInput'
    connect: 'UserAnswerWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserAnswerUpdateInput'
    # upsert: 'UserAnswerUpsertWithoutRelationsInput'
    # connectOrCreate: 'UserAnswerCreateOrConnectWithoutRelationsInput'


class UserAnswerUpsertInput(TypedDict):
    create: 'UserAnswerCreateInput'
    update: 'UserAnswerUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_UserAnswer_id_OrderByInput = TypedDict(
    '_UserAnswer_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_UserAnswer_idNumber_OrderByInput = TypedDict(
    '_UserAnswer_idNumber_OrderByInput',
    {
        'idNumber': 'SortOrder',
    },
    total=True
)

_UserAnswer_fullName_OrderByInput = TypedDict(
    '_UserAnswer_fullName_OrderByInput',
    {
        'fullName': 'SortOrder',
    },
    total=True
)

_UserAnswer_settlementCode_OrderByInput = TypedDict(
    '_UserAnswer_settlementCode_OrderByInput',
    {
        'settlementCode': 'SortOrder',
    },
    total=True
)

_UserAnswer_accessibility_OrderByInput = TypedDict(
    '_UserAnswer_accessibility_OrderByInput',
    {
        'accessibility': 'SortOrder',
    },
    total=True
)

_UserAnswer_pets_OrderByInput = TypedDict(
    '_UserAnswer_pets_OrderByInput',
    {
        'pets': 'SortOrder',
    },
    total=True
)

_UserAnswer_numberOfPeople_OrderByInput = TypedDict(
    '_UserAnswer_numberOfPeople_OrderByInput',
    {
        'numberOfPeople': 'SortOrder',
    },
    total=True
)

_UserAnswer_hotelOption1_OrderByInput = TypedDict(
    '_UserAnswer_hotelOption1_OrderByInput',
    {
        'hotelOption1': 'SortOrder',
    },
    total=True
)

_UserAnswer_hotelOption2_OrderByInput = TypedDict(
    '_UserAnswer_hotelOption2_OrderByInput',
    {
        'hotelOption2': 'SortOrder',
    },
    total=True
)

_UserAnswer_hotelOption3_OrderByInput = TypedDict(
    '_UserAnswer_hotelOption3_OrderByInput',
    {
        'hotelOption3': 'SortOrder',
    },
    total=True
)

_UserAnswer_selectedHotel_OrderByInput = TypedDict(
    '_UserAnswer_selectedHotel_OrderByInput',
    {
        'selectedHotel': 'SortOrder',
    },
    total=True
)

UserAnswerOrderByInput = Union[
    '_UserAnswer_id_OrderByInput',
    '_UserAnswer_idNumber_OrderByInput',
    '_UserAnswer_fullName_OrderByInput',
    '_UserAnswer_settlementCode_OrderByInput',
    '_UserAnswer_accessibility_OrderByInput',
    '_UserAnswer_pets_OrderByInput',
    '_UserAnswer_numberOfPeople_OrderByInput',
    '_UserAnswer_hotelOption1_OrderByInput',
    '_UserAnswer_hotelOption2_OrderByInput',
    '_UserAnswer_hotelOption3_OrderByInput',
    '_UserAnswer_selectedHotel_OrderByInput',
]



# recursive UserAnswer types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

UserAnswerRelationFilter = TypedDict(
    'UserAnswerRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class UserAnswerListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class UserAnswerInclude(TypedDict, total=False):
    """UserAnswer relational arguments"""
    settlement: Union[bool, 'SettlementArgsFromUserAnswer']


    

class UserAnswerIncludeFromUserAnswer(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    settlement: Union[bool, 'SettlementArgsFromUserAnswerRecursive1']


class UserAnswerIncludeFromUserAnswerRecursive1(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    settlement: Union[bool, 'SettlementArgsFromUserAnswerRecursive2']


class UserAnswerIncludeFromUserAnswerRecursive2(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    settlement: Union[bool, 'SettlementArgsFromUserAnswerRecursive3']


class UserAnswerIncludeFromUserAnswerRecursive3(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    settlement: Union[bool, 'SettlementArgsFromUserAnswerRecursive4']


class UserAnswerIncludeFromUserAnswerRecursive4(TypedDict, total=False):
    """Relational arguments for UserAnswer"""

    

class UserAnswerArgsFromUserAnswer(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive1'


class UserAnswerArgsFromUserAnswerRecursive1(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive2'


class UserAnswerArgsFromUserAnswerRecursive2(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive3'


class UserAnswerArgsFromUserAnswerRecursive3(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive4'


class UserAnswerArgsFromUserAnswerRecursive4(TypedDict, total=False):
    """Arguments for UserAnswer"""
    
    

class FindManyUserAnswerArgsFromUserAnswer(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive1'


class FindManyUserAnswerArgsFromUserAnswerRecursive1(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive2'


class FindManyUserAnswerArgsFromUserAnswerRecursive2(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive3'


class FindManyUserAnswerArgsFromUserAnswerRecursive3(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive4'


class FindManyUserAnswerArgsFromUserAnswerRecursive4(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    
    

class SettlementIncludeFromUserAnswer(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromUserAnswerRecursive1']


class SettlementIncludeFromUserAnswerRecursive1(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromUserAnswerRecursive2']


class SettlementIncludeFromUserAnswerRecursive2(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromUserAnswerRecursive3']


class SettlementIncludeFromUserAnswerRecursive3(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromUserAnswerRecursive4']


class SettlementIncludeFromUserAnswerRecursive4(TypedDict, total=False):
    """Relational arguments for UserAnswer"""

    

class SettlementArgsFromUserAnswer(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'SettlementIncludeFromSettlementRecursive1'


class SettlementArgsFromUserAnswerRecursive1(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'SettlementIncludeFromSettlementRecursive2'


class SettlementArgsFromUserAnswerRecursive2(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'SettlementIncludeFromSettlementRecursive3'


class SettlementArgsFromUserAnswerRecursive3(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'SettlementIncludeFromSettlementRecursive4'


class SettlementArgsFromUserAnswerRecursive4(TypedDict, total=False):
    """Arguments for UserAnswer"""
    
    

class FindManySettlementArgsFromUserAnswer(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive1'


class FindManySettlementArgsFromUserAnswerRecursive1(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive2'


class FindManySettlementArgsFromUserAnswerRecursive2(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive3'


class FindManySettlementArgsFromUserAnswerRecursive3(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive4'


class FindManySettlementArgsFromUserAnswerRecursive4(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    


FindManyUserAnswerArgs = FindManyUserAnswerArgsFromUserAnswer
FindFirstUserAnswerArgs = FindManyUserAnswerArgsFromUserAnswer


    

class UserAnswerWhereInput(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    idNumber: Union[_str, 'types.StringFilter']
    fullName: Union[_str, 'types.StringFilter']
    settlementCode: Union[_int, 'types.IntFilter']
    accessibility: Union[_bool, 'types.BooleanFilter']
    pets: Union[_bool, 'types.BooleanFilter']
    numberOfPeople: Union[_int, 'types.IntFilter']
    hotelOption1: Union[None, _str, 'types.StringFilter']
    hotelOption2: Union[None, _str, 'types.StringFilter']
    hotelOption3: Union[None, _str, 'types.StringFilter']
    selectedHotel: Union[None, _str, 'types.StringFilter']
    settlement: 'SettlementRelationFilter'

    # should be noted that AND and NOT should be Union['UserAnswerWhereInputRecursive1', List['UserAnswerWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['UserAnswerWhereInputRecursive1']
    OR: List['UserAnswerWhereInputRecursive1']
    NOT: List['UserAnswerWhereInputRecursive1']


class UserAnswerWhereInputRecursive1(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    idNumber: Union[_str, 'types.StringFilter']
    fullName: Union[_str, 'types.StringFilter']
    settlementCode: Union[_int, 'types.IntFilter']
    accessibility: Union[_bool, 'types.BooleanFilter']
    pets: Union[_bool, 'types.BooleanFilter']
    numberOfPeople: Union[_int, 'types.IntFilter']
    hotelOption1: Union[None, _str, 'types.StringFilter']
    hotelOption2: Union[None, _str, 'types.StringFilter']
    hotelOption3: Union[None, _str, 'types.StringFilter']
    selectedHotel: Union[None, _str, 'types.StringFilter']
    settlement: 'SettlementRelationFilter'

    # should be noted that AND and NOT should be Union['UserAnswerWhereInputRecursive2', List['UserAnswerWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['UserAnswerWhereInputRecursive2']
    OR: List['UserAnswerWhereInputRecursive2']
    NOT: List['UserAnswerWhereInputRecursive2']


class UserAnswerWhereInputRecursive2(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    idNumber: Union[_str, 'types.StringFilter']
    fullName: Union[_str, 'types.StringFilter']
    settlementCode: Union[_int, 'types.IntFilter']
    accessibility: Union[_bool, 'types.BooleanFilter']
    pets: Union[_bool, 'types.BooleanFilter']
    numberOfPeople: Union[_int, 'types.IntFilter']
    hotelOption1: Union[None, _str, 'types.StringFilter']
    hotelOption2: Union[None, _str, 'types.StringFilter']
    hotelOption3: Union[None, _str, 'types.StringFilter']
    selectedHotel: Union[None, _str, 'types.StringFilter']
    settlement: 'SettlementRelationFilter'

    # should be noted that AND and NOT should be Union['UserAnswerWhereInputRecursive3', List['UserAnswerWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['UserAnswerWhereInputRecursive3']
    OR: List['UserAnswerWhereInputRecursive3']
    NOT: List['UserAnswerWhereInputRecursive3']


class UserAnswerWhereInputRecursive3(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    idNumber: Union[_str, 'types.StringFilter']
    fullName: Union[_str, 'types.StringFilter']
    settlementCode: Union[_int, 'types.IntFilter']
    accessibility: Union[_bool, 'types.BooleanFilter']
    pets: Union[_bool, 'types.BooleanFilter']
    numberOfPeople: Union[_int, 'types.IntFilter']
    hotelOption1: Union[None, _str, 'types.StringFilter']
    hotelOption2: Union[None, _str, 'types.StringFilter']
    hotelOption3: Union[None, _str, 'types.StringFilter']
    selectedHotel: Union[None, _str, 'types.StringFilter']
    settlement: 'SettlementRelationFilter'

    # should be noted that AND and NOT should be Union['UserAnswerWhereInputRecursive4', List['UserAnswerWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['UserAnswerWhereInputRecursive4']
    OR: List['UserAnswerWhereInputRecursive4']
    NOT: List['UserAnswerWhereInputRecursive4']


class UserAnswerWhereInputRecursive4(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    idNumber: Union[_str, 'types.StringFilter']
    fullName: Union[_str, 'types.StringFilter']
    settlementCode: Union[_int, 'types.IntFilter']
    accessibility: Union[_bool, 'types.BooleanFilter']
    pets: Union[_bool, 'types.BooleanFilter']
    numberOfPeople: Union[_int, 'types.IntFilter']
    hotelOption1: Union[None, _str, 'types.StringFilter']
    hotelOption2: Union[None, _str, 'types.StringFilter']
    hotelOption3: Union[None, _str, 'types.StringFilter']
    selectedHotel: Union[None, _str, 'types.StringFilter']
    settlement: 'SettlementRelationFilter'



# aggregate UserAnswer types


    

class UserAnswerScalarWhereWithAggregatesInput(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    idNumber: Union[_str, 'types.StringWithAggregatesFilter']
    fullName: Union[_str, 'types.StringWithAggregatesFilter']
    settlementCode: Union[_int, 'types.IntWithAggregatesFilter']
    accessibility: Union[_bool, 'types.BooleanWithAggregatesFilter']
    pets: Union[_bool, 'types.BooleanWithAggregatesFilter']
    numberOfPeople: Union[_int, 'types.IntWithAggregatesFilter']
    hotelOption1: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption2: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption3: Union[_str, 'types.StringWithAggregatesFilter']
    selectedHotel: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserAnswerScalarWhereWithAggregatesInputRecursive1']
    OR: List['UserAnswerScalarWhereWithAggregatesInputRecursive1']
    NOT: List['UserAnswerScalarWhereWithAggregatesInputRecursive1']


class UserAnswerScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    idNumber: Union[_str, 'types.StringWithAggregatesFilter']
    fullName: Union[_str, 'types.StringWithAggregatesFilter']
    settlementCode: Union[_int, 'types.IntWithAggregatesFilter']
    accessibility: Union[_bool, 'types.BooleanWithAggregatesFilter']
    pets: Union[_bool, 'types.BooleanWithAggregatesFilter']
    numberOfPeople: Union[_int, 'types.IntWithAggregatesFilter']
    hotelOption1: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption2: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption3: Union[_str, 'types.StringWithAggregatesFilter']
    selectedHotel: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserAnswerScalarWhereWithAggregatesInputRecursive2']
    OR: List['UserAnswerScalarWhereWithAggregatesInputRecursive2']
    NOT: List['UserAnswerScalarWhereWithAggregatesInputRecursive2']


class UserAnswerScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    idNumber: Union[_str, 'types.StringWithAggregatesFilter']
    fullName: Union[_str, 'types.StringWithAggregatesFilter']
    settlementCode: Union[_int, 'types.IntWithAggregatesFilter']
    accessibility: Union[_bool, 'types.BooleanWithAggregatesFilter']
    pets: Union[_bool, 'types.BooleanWithAggregatesFilter']
    numberOfPeople: Union[_int, 'types.IntWithAggregatesFilter']
    hotelOption1: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption2: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption3: Union[_str, 'types.StringWithAggregatesFilter']
    selectedHotel: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserAnswerScalarWhereWithAggregatesInputRecursive3']
    OR: List['UserAnswerScalarWhereWithAggregatesInputRecursive3']
    NOT: List['UserAnswerScalarWhereWithAggregatesInputRecursive3']


class UserAnswerScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    idNumber: Union[_str, 'types.StringWithAggregatesFilter']
    fullName: Union[_str, 'types.StringWithAggregatesFilter']
    settlementCode: Union[_int, 'types.IntWithAggregatesFilter']
    accessibility: Union[_bool, 'types.BooleanWithAggregatesFilter']
    pets: Union[_bool, 'types.BooleanWithAggregatesFilter']
    numberOfPeople: Union[_int, 'types.IntWithAggregatesFilter']
    hotelOption1: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption2: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption3: Union[_str, 'types.StringWithAggregatesFilter']
    selectedHotel: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserAnswerScalarWhereWithAggregatesInputRecursive4']
    OR: List['UserAnswerScalarWhereWithAggregatesInputRecursive4']
    NOT: List['UserAnswerScalarWhereWithAggregatesInputRecursive4']


class UserAnswerScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    idNumber: Union[_str, 'types.StringWithAggregatesFilter']
    fullName: Union[_str, 'types.StringWithAggregatesFilter']
    settlementCode: Union[_int, 'types.IntWithAggregatesFilter']
    accessibility: Union[_bool, 'types.BooleanWithAggregatesFilter']
    pets: Union[_bool, 'types.BooleanWithAggregatesFilter']
    numberOfPeople: Union[_int, 'types.IntWithAggregatesFilter']
    hotelOption1: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption2: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption3: Union[_str, 'types.StringWithAggregatesFilter']
    selectedHotel: Union[_str, 'types.StringWithAggregatesFilter']



class UserAnswerGroupByOutput(TypedDict, total=False):
    id: _int
    idNumber: _str
    fullName: _str
    settlementCode: _int
    accessibility: _bool
    pets: _bool
    numberOfPeople: _int
    hotelOption1: _str
    hotelOption2: _str
    hotelOption3: _str
    selectedHotel: _str
    _sum: 'UserAnswerSumAggregateOutput'
    _avg: 'UserAnswerAvgAggregateOutput'
    _min: 'UserAnswerMinAggregateOutput'
    _max: 'UserAnswerMaxAggregateOutput'
    _count: 'UserAnswerCountAggregateOutput'


class UserAnswerAvgAggregateOutput(TypedDict, total=False):
    """UserAnswer output for aggregating averages"""
    id: float
    settlementCode: float
    numberOfPeople: float


class UserAnswerSumAggregateOutput(TypedDict, total=False):
    """UserAnswer output for aggregating sums"""
    id: _int
    settlementCode: _int
    numberOfPeople: _int


class UserAnswerScalarAggregateOutput(TypedDict, total=False):
    """UserAnswer output including scalar fields"""
    id: _int
    idNumber: _str
    fullName: _str
    settlementCode: _int
    accessibility: _bool
    pets: _bool
    numberOfPeople: _int
    hotelOption1: _str
    hotelOption2: _str
    hotelOption3: _str
    selectedHotel: _str


UserAnswerMinAggregateOutput = UserAnswerScalarAggregateOutput
UserAnswerMaxAggregateOutput = UserAnswerScalarAggregateOutput


class UserAnswerMaxAggregateInput(TypedDict, total=False):
    """UserAnswer input for aggregating by max"""
    id: bool
    idNumber: bool
    fullName: bool
    settlementCode: bool
    accessibility: bool
    pets: bool
    numberOfPeople: bool
    hotelOption1: bool
    hotelOption2: bool
    hotelOption3: bool
    selectedHotel: bool


class UserAnswerMinAggregateInput(TypedDict, total=False):
    """UserAnswer input for aggregating by min"""
    id: bool
    idNumber: bool
    fullName: bool
    settlementCode: bool
    accessibility: bool
    pets: bool
    numberOfPeople: bool
    hotelOption1: bool
    hotelOption2: bool
    hotelOption3: bool
    selectedHotel: bool


class UserAnswerNumberAggregateInput(TypedDict, total=False):
    """UserAnswer input for aggregating numbers"""
    id: bool
    settlementCode: bool
    numberOfPeople: bool


UserAnswerAvgAggregateInput = UserAnswerNumberAggregateInput
UserAnswerSumAggregateInput = UserAnswerNumberAggregateInput


UserAnswerCountAggregateInput = TypedDict(
    'UserAnswerCountAggregateInput',
    {
        'id': bool,
        'idNumber': bool,
        'fullName': bool,
        'settlementCode': bool,
        'accessibility': bool,
        'pets': bool,
        'numberOfPeople': bool,
        'hotelOption1': bool,
        'hotelOption2': bool,
        'hotelOption3': bool,
        'selectedHotel': bool,
        '_all': bool,
    },
    total=False,
)

UserAnswerCountAggregateOutput = TypedDict(
    'UserAnswerCountAggregateOutput',
    {
        'id': int,
        'idNumber': int,
        'fullName': int,
        'settlementCode': int,
        'accessibility': int,
        'pets': int,
        'numberOfPeople': int,
        'hotelOption1': int,
        'hotelOption2': int,
        'hotelOption3': int,
        'selectedHotel': int,
        '_all': int,
    },
    total=False,
)


UserAnswerKeys = Literal[
    'id',
    'idNumber',
    'fullName',
    'settlementCode',
    'accessibility',
    'pets',
    'numberOfPeople',
    'hotelOption1',
    'hotelOption2',
    'hotelOption3',
    'selectedHotel',
    'settlement',
]
UserAnswerScalarFieldKeys = Literal[
    'id',
    'idNumber',
    'fullName',
    'settlementCode',
    'accessibility',
    'pets',
    'numberOfPeople',
    'hotelOption1',
    'hotelOption2',
    'hotelOption3',
    'selectedHotel',
]
UserAnswerScalarFieldKeysT = TypeVar('UserAnswerScalarFieldKeysT', bound=UserAnswerScalarFieldKeys)

UserAnswerRelationalFieldKeys = Literal[
        'settlement',
    ]

# Settlement types

class SettlementOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Settlement create method"""
    id: _int
    alias1: Optional[_str]
    alias2: Optional[_str]
    alias3: Optional[_str]
    userAnswers: 'UserAnswerCreateManyNestedWithoutRelationsInput'


class SettlementCreateInput(SettlementOptionalCreateInput):
    """Required arguments to the Settlement create method"""
    code: _int
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SettlementOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Settlement create method, without relations"""
    id: _int
    alias1: Optional[_str]
    alias2: Optional[_str]
    alias3: Optional[_str]


class SettlementCreateWithoutRelationsInput(SettlementOptionalCreateWithoutRelationsInput):
    """Required arguments to the Settlement create method, without relations"""
    code: _int
    name: _str


class SettlementCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SettlementCreateWithoutRelationsInput'
    connect: 'SettlementWhereUniqueInput'


class SettlementCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SettlementCreateWithoutRelationsInput', List['SettlementCreateWithoutRelationsInput']]
    connect: Union['SettlementWhereUniqueInput', List['SettlementWhereUniqueInput']]


_SettlementWhereUnique_id_Input = TypedDict(
    '_SettlementWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_SettlementWhereUnique_code_Input = TypedDict(
    '_SettlementWhereUnique_code_Input',
    {
        'code': '_int',
    },
    total=True
)

SettlementWhereUniqueInput = Union[
    '_SettlementWhereUnique_id_Input',
    '_SettlementWhereUnique_code_Input',
]


class SettlementUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    code: Union[AtomicIntInput, _int]
    name: _str
    alias1: Optional[_str]
    alias2: Optional[_str]
    alias3: Optional[_str]
    userAnswers: 'UserAnswerUpdateManyWithoutRelationsInput'


class SettlementUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    code: Union[AtomicIntInput, _int]
    name: _str
    alias1: Optional[_str]
    alias2: Optional[_str]
    alias3: Optional[_str]


class SettlementUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SettlementCreateWithoutRelationsInput']
    connect: List['SettlementWhereUniqueInput']
    set: List['SettlementWhereUniqueInput']
    disconnect: List['SettlementWhereUniqueInput']
    delete: List['SettlementWhereUniqueInput']

    # TODO
    # update: List['SettlementUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SettlementUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SettlementScalarWhereInput']
    # upsert: List['SettlementUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['SettlementCreateOrConnectWithoutRelationsInput']


class SettlementUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SettlementCreateWithoutRelationsInput'
    connect: 'SettlementWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SettlementUpdateInput'
    # upsert: 'SettlementUpsertWithoutRelationsInput'
    # connectOrCreate: 'SettlementCreateOrConnectWithoutRelationsInput'


class SettlementUpsertInput(TypedDict):
    create: 'SettlementCreateInput'
    update: 'SettlementUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Settlement_id_OrderByInput = TypedDict(
    '_Settlement_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Settlement_code_OrderByInput = TypedDict(
    '_Settlement_code_OrderByInput',
    {
        'code': 'SortOrder',
    },
    total=True
)

_Settlement_name_OrderByInput = TypedDict(
    '_Settlement_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Settlement_alias1_OrderByInput = TypedDict(
    '_Settlement_alias1_OrderByInput',
    {
        'alias1': 'SortOrder',
    },
    total=True
)

_Settlement_alias2_OrderByInput = TypedDict(
    '_Settlement_alias2_OrderByInput',
    {
        'alias2': 'SortOrder',
    },
    total=True
)

_Settlement_alias3_OrderByInput = TypedDict(
    '_Settlement_alias3_OrderByInput',
    {
        'alias3': 'SortOrder',
    },
    total=True
)

SettlementOrderByInput = Union[
    '_Settlement_id_OrderByInput',
    '_Settlement_code_OrderByInput',
    '_Settlement_name_OrderByInput',
    '_Settlement_alias1_OrderByInput',
    '_Settlement_alias2_OrderByInput',
    '_Settlement_alias3_OrderByInput',
]



# recursive Settlement types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

SettlementRelationFilter = TypedDict(
    'SettlementRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class SettlementListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class SettlementInclude(TypedDict, total=False):
    """Settlement relational arguments"""
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromSettlement']


    

class UserAnswerIncludeFromSettlement(TypedDict, total=False):
    """Relational arguments for Settlement"""
    settlement: Union[bool, 'SettlementArgsFromSettlementRecursive1']


class UserAnswerIncludeFromSettlementRecursive1(TypedDict, total=False):
    """Relational arguments for Settlement"""
    settlement: Union[bool, 'SettlementArgsFromSettlementRecursive2']


class UserAnswerIncludeFromSettlementRecursive2(TypedDict, total=False):
    """Relational arguments for Settlement"""
    settlement: Union[bool, 'SettlementArgsFromSettlementRecursive3']


class UserAnswerIncludeFromSettlementRecursive3(TypedDict, total=False):
    """Relational arguments for Settlement"""
    settlement: Union[bool, 'SettlementArgsFromSettlementRecursive4']


class UserAnswerIncludeFromSettlementRecursive4(TypedDict, total=False):
    """Relational arguments for Settlement"""

    

class UserAnswerArgsFromSettlement(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive1'


class UserAnswerArgsFromSettlementRecursive1(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive2'


class UserAnswerArgsFromSettlementRecursive2(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive3'


class UserAnswerArgsFromSettlementRecursive3(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive4'


class UserAnswerArgsFromSettlementRecursive4(TypedDict, total=False):
    """Arguments for Settlement"""
    
    

class FindManyUserAnswerArgsFromSettlement(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive1'


class FindManyUserAnswerArgsFromSettlementRecursive1(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive2'


class FindManyUserAnswerArgsFromSettlementRecursive2(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive3'


class FindManyUserAnswerArgsFromSettlementRecursive3(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive4'


class FindManyUserAnswerArgsFromSettlementRecursive4(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    
    

class SettlementIncludeFromSettlement(TypedDict, total=False):
    """Relational arguments for Settlement"""
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromSettlementRecursive1']


class SettlementIncludeFromSettlementRecursive1(TypedDict, total=False):
    """Relational arguments for Settlement"""
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromSettlementRecursive2']


class SettlementIncludeFromSettlementRecursive2(TypedDict, total=False):
    """Relational arguments for Settlement"""
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromSettlementRecursive3']


class SettlementIncludeFromSettlementRecursive3(TypedDict, total=False):
    """Relational arguments for Settlement"""
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromSettlementRecursive4']


class SettlementIncludeFromSettlementRecursive4(TypedDict, total=False):
    """Relational arguments for Settlement"""

    

class SettlementArgsFromSettlement(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'SettlementIncludeFromSettlementRecursive1'


class SettlementArgsFromSettlementRecursive1(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'SettlementIncludeFromSettlementRecursive2'


class SettlementArgsFromSettlementRecursive2(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'SettlementIncludeFromSettlementRecursive3'


class SettlementArgsFromSettlementRecursive3(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'SettlementIncludeFromSettlementRecursive4'


class SettlementArgsFromSettlementRecursive4(TypedDict, total=False):
    """Arguments for Settlement"""
    
    

class FindManySettlementArgsFromSettlement(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive1'


class FindManySettlementArgsFromSettlementRecursive1(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive2'


class FindManySettlementArgsFromSettlementRecursive2(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive3'


class FindManySettlementArgsFromSettlementRecursive3(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive4'


class FindManySettlementArgsFromSettlementRecursive4(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    


FindManySettlementArgs = FindManySettlementArgsFromSettlement
FindFirstSettlementArgs = FindManySettlementArgsFromSettlement


    

class SettlementWhereInput(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    code: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    alias1: Union[None, _str, 'types.StringFilter']
    alias2: Union[None, _str, 'types.StringFilter']
    alias3: Union[None, _str, 'types.StringFilter']
    userAnswers: 'UserAnswerListRelationFilter'

    # should be noted that AND and NOT should be Union['SettlementWhereInputRecursive1', List['SettlementWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['SettlementWhereInputRecursive1']
    OR: List['SettlementWhereInputRecursive1']
    NOT: List['SettlementWhereInputRecursive1']


class SettlementWhereInputRecursive1(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    code: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    alias1: Union[None, _str, 'types.StringFilter']
    alias2: Union[None, _str, 'types.StringFilter']
    alias3: Union[None, _str, 'types.StringFilter']
    userAnswers: 'UserAnswerListRelationFilter'

    # should be noted that AND and NOT should be Union['SettlementWhereInputRecursive2', List['SettlementWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['SettlementWhereInputRecursive2']
    OR: List['SettlementWhereInputRecursive2']
    NOT: List['SettlementWhereInputRecursive2']


class SettlementWhereInputRecursive2(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    code: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    alias1: Union[None, _str, 'types.StringFilter']
    alias2: Union[None, _str, 'types.StringFilter']
    alias3: Union[None, _str, 'types.StringFilter']
    userAnswers: 'UserAnswerListRelationFilter'

    # should be noted that AND and NOT should be Union['SettlementWhereInputRecursive3', List['SettlementWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['SettlementWhereInputRecursive3']
    OR: List['SettlementWhereInputRecursive3']
    NOT: List['SettlementWhereInputRecursive3']


class SettlementWhereInputRecursive3(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    code: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    alias1: Union[None, _str, 'types.StringFilter']
    alias2: Union[None, _str, 'types.StringFilter']
    alias3: Union[None, _str, 'types.StringFilter']
    userAnswers: 'UserAnswerListRelationFilter'

    # should be noted that AND and NOT should be Union['SettlementWhereInputRecursive4', List['SettlementWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['SettlementWhereInputRecursive4']
    OR: List['SettlementWhereInputRecursive4']
    NOT: List['SettlementWhereInputRecursive4']


class SettlementWhereInputRecursive4(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    code: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    alias1: Union[None, _str, 'types.StringFilter']
    alias2: Union[None, _str, 'types.StringFilter']
    alias3: Union[None, _str, 'types.StringFilter']
    userAnswers: 'UserAnswerListRelationFilter'



# aggregate Settlement types


    

class SettlementScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    code: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    alias1: Union[_str, 'types.StringWithAggregatesFilter']
    alias2: Union[_str, 'types.StringWithAggregatesFilter']
    alias3: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SettlementScalarWhereWithAggregatesInputRecursive1']
    OR: List['SettlementScalarWhereWithAggregatesInputRecursive1']
    NOT: List['SettlementScalarWhereWithAggregatesInputRecursive1']


class SettlementScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    code: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    alias1: Union[_str, 'types.StringWithAggregatesFilter']
    alias2: Union[_str, 'types.StringWithAggregatesFilter']
    alias3: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SettlementScalarWhereWithAggregatesInputRecursive2']
    OR: List['SettlementScalarWhereWithAggregatesInputRecursive2']
    NOT: List['SettlementScalarWhereWithAggregatesInputRecursive2']


class SettlementScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    code: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    alias1: Union[_str, 'types.StringWithAggregatesFilter']
    alias2: Union[_str, 'types.StringWithAggregatesFilter']
    alias3: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SettlementScalarWhereWithAggregatesInputRecursive3']
    OR: List['SettlementScalarWhereWithAggregatesInputRecursive3']
    NOT: List['SettlementScalarWhereWithAggregatesInputRecursive3']


class SettlementScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    code: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    alias1: Union[_str, 'types.StringWithAggregatesFilter']
    alias2: Union[_str, 'types.StringWithAggregatesFilter']
    alias3: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SettlementScalarWhereWithAggregatesInputRecursive4']
    OR: List['SettlementScalarWhereWithAggregatesInputRecursive4']
    NOT: List['SettlementScalarWhereWithAggregatesInputRecursive4']


class SettlementScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    code: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    alias1: Union[_str, 'types.StringWithAggregatesFilter']
    alias2: Union[_str, 'types.StringWithAggregatesFilter']
    alias3: Union[_str, 'types.StringWithAggregatesFilter']



class SettlementGroupByOutput(TypedDict, total=False):
    id: _int
    code: _int
    name: _str
    alias1: _str
    alias2: _str
    alias3: _str
    _sum: 'SettlementSumAggregateOutput'
    _avg: 'SettlementAvgAggregateOutput'
    _min: 'SettlementMinAggregateOutput'
    _max: 'SettlementMaxAggregateOutput'
    _count: 'SettlementCountAggregateOutput'


class SettlementAvgAggregateOutput(TypedDict, total=False):
    """Settlement output for aggregating averages"""
    id: float
    code: float


class SettlementSumAggregateOutput(TypedDict, total=False):
    """Settlement output for aggregating sums"""
    id: _int
    code: _int


class SettlementScalarAggregateOutput(TypedDict, total=False):
    """Settlement output including scalar fields"""
    id: _int
    code: _int
    name: _str
    alias1: _str
    alias2: _str
    alias3: _str


SettlementMinAggregateOutput = SettlementScalarAggregateOutput
SettlementMaxAggregateOutput = SettlementScalarAggregateOutput


class SettlementMaxAggregateInput(TypedDict, total=False):
    """Settlement input for aggregating by max"""
    id: bool
    code: bool
    name: bool
    alias1: bool
    alias2: bool
    alias3: bool


class SettlementMinAggregateInput(TypedDict, total=False):
    """Settlement input for aggregating by min"""
    id: bool
    code: bool
    name: bool
    alias1: bool
    alias2: bool
    alias3: bool


class SettlementNumberAggregateInput(TypedDict, total=False):
    """Settlement input for aggregating numbers"""
    id: bool
    code: bool


SettlementAvgAggregateInput = SettlementNumberAggregateInput
SettlementSumAggregateInput = SettlementNumberAggregateInput


SettlementCountAggregateInput = TypedDict(
    'SettlementCountAggregateInput',
    {
        'id': bool,
        'code': bool,
        'name': bool,
        'alias1': bool,
        'alias2': bool,
        'alias3': bool,
        '_all': bool,
    },
    total=False,
)

SettlementCountAggregateOutput = TypedDict(
    'SettlementCountAggregateOutput',
    {
        'id': int,
        'code': int,
        'name': int,
        'alias1': int,
        'alias2': int,
        'alias3': int,
        '_all': int,
    },
    total=False,
)


SettlementKeys = Literal[
    'id',
    'code',
    'name',
    'alias1',
    'alias2',
    'alias3',
    'userAnswers',
]
SettlementScalarFieldKeys = Literal[
    'id',
    'code',
    'name',
    'alias1',
    'alias2',
    'alias3',
]
SettlementScalarFieldKeysT = TypeVar('SettlementScalarFieldKeysT', bound=SettlementScalarFieldKeys)

SettlementRelationalFieldKeys = Literal[
        'userAnswers',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields